\input{thispreamble.tex}

\renewcommand\AUTHOR{nweadick1@cougars.ccis.edu} % CHANGE TO YOURS

\begin{document}
\topmattertwo


%------------------------------------------------------------------------------
\nextq
You are given this:
\begin{console}[fontsize=\small]
type 'a btree = Empty
              | Node of ('a * 'a btree * 'a btree)
;;
\end{console}
write three functions \verb!preorder!, \verb!inorder!, and \verb!postorder!
that returns a list of the keys in a \verb!'a btree! traversed using
preorder, inorder, and postorder traversal (respectively).
You need not use tail recursion.
Here's an example test case:
\begin{console}[fontsize=\small]
let t =
  Node (
    0,
    Node (
      2,
      Empty,
      Empty
    ),
    Node (
      1,
      Node (3, Empty, Empty),
      Node (4, Empty, Empty)
    )
  )
;;
preorder t;;
inorder t;;
postorder t;;
\end{console}
Here's the console output:
\begin{console}[fontsize=\small]
val t : int btree =
  Node
   (0, Node (2, Empty, Empty),
    Node (1, Node (3, Empty, Empty), Node (4, Empty, Empty)))
# preorder t;;
- : int list = [0; 2; 1; 3; 4]
# inorder t;;
- : int list = [2; 0; 3; 1; 4]
# postorder t;;
- : int list = [2; 3; 4; 1; 0]
\end{console}
\\
\ANSWER
\begin{answercode}
let rec preorder = fun b -> match b with Empty -> []
| Node (root,left,right) -> [root]  @(preorder left) @ (preorder right);;


let rec inorder = fun b -> match b with Empty -> []
| Node (root,left,right) ->  (inorder left) @ [root] @ (inorder right);;

let rec postorder = fun b -> match b with Empty -> []
| Node (root,left,right) ->  (postorder left) @ (postorder right) @ [root];;
\end{answercode}


%------------------------------------------------------------------------------
\newpage
\input{instructions.tex}
\end{document}
